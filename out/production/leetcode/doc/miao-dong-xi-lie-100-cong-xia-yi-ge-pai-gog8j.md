# 朴素解法

找下一个排列的数。大家可以先想想大脑来是怎么完成这个找数的过程的。

**我们会尽可能的将低位的数字变大，这样才符合「下一个排列」的定义。**

也就是从低位往高位检查，观察某一位在「下一个排列」中是否可以被更大的数代替。

那么如何判断某一位能够被更大的数代替呢？

**其实就是将 `k` 位到低位的所有数作为候选，判断是否有更大的数可以填入 `k` 位中。**

假设当前我们检查到 `k` 位，要分析第 `k` 位在「下一个排列」中是否能被更大的数代替。

我们会先假定高位到 `k` 位的数不变，在 `k` 位到低位中是否有比 `k` 位上的数更大的数，如果有说明 `k` 在「下一个排列」中变大。

换句话说，我们要找的第 `k` 位其实就是从低位到高位的第一个下降的数。

...

为了更好理解，我们结合样例来分析，假设样例为 `[1,3,5,4,1]`：

1. **从后往前找，找到第一个下降的位置，记为 `k`。注意`k` 以后的位置是降序的。** 在样例中就是找到 3

2. **从 k 往后找，找到最小的比 k 要大的数。** 找到 4

3. **将两者交换。注意此时 `k` 以后的位置仍然是降序的。**

4. **直接将 k 以后的部分翻转（变为升序）。**

注意：如果在步骤 1 中找到头部还没找到，说明该序列已经是字典序最大的排列。按照题意，我们要将数组重新排列成最小的排列。

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int k = n - 1;
        while (k - 1 >= 0 && nums[k - 1] >= nums[k]) k--;
        if (k == 0) {
            reverse(nums, 0, n - 1);
        } else {
            int u = k;
            while (u + 1 < n && nums[u + 1] > nums[k - 1]) u++;
            swap(nums, k - 1, u);
            reverse(nums, k, n - 1);
        }
    }
    void reverse(int[] nums, int a, int b) {
        int l = a, r = b;
        while (l < r) {
            swap(nums, l++, r--);
        }
    }
    void swap(int[] nums, int a, int b) {
        int c = nums[a];
        nums[a] = nums[b];
        nums[b] = c;
    }
}
```
* 时间复杂度：对数组线性遍历。复杂度为 *O(n)*

* 空间复杂度：*O(1)*

***
### 最后

如果有帮助到你，请给个点赞关注，让更多的人看到 ~ ("▔□▔)/

也欢迎你 [关注我](http://wechat.peterxx.com/qr_code_promote.html) ，和三叶一起刷穿 LeetCode ~ 